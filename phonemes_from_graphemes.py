import logging
import shelve
from subprocess import check_output
from timeit import default_timer as timer
from os import listdir
from os.path import isfile, join

class SoundsDict:
    """
        Handles a set of 'shelves' as part of a unified dictionary
    """

    def __file_name_2_shelf_or_None__(self, shelf_filename: str):
        try:
            return shelve.open(shelf_filename, flag='r')
        except Exception as e:
            self.alogger.error("Impossible to open '{}': {}".format(shelf_filename, str(e)))
            return None

    def __init__(self, a_dir: str, alogger: logging.Logger):
        """
        
        :param a_dir: Directory where shelves live. Generated by functions below.
        :param alogger: 
        """
        if not os.path.exists(a_dir):
            err_msg = "Directory '{}' does not exist".format(a_dir)
            alogger.error(err_msg)
            assert False
        self.alogger = alogger
        # read shelves files from directory:
        file_names = [os.path.join(a_dir, os.path.splitext(f)[0]) for
                      f in [f for f in listdir(a_dir) if isfile(join(a_dir, f)) and "shelf" in f and "from" in f and "for" in f]]
        self.all_shelves = []
        if len(file_names) == 0:
            self.alogger.warning("There are no sounds dictionaries in directory '{}'".format(a_dir))
        else:
            self.alogger.debug("Initializing with shelves {}".format(file_names))
            self.all_shelves = list(map(self.__file_name_2_shelf_or_None__, file_names))
            self.all_shelves = [ a_shelf for a_shelf in self.all_shelves if a_shelf is not None ]

    def __getitem__(self, key):
        """
        Index operator 
        Args:
            key: 

        Returns: the value 
        """
        def get_from_dict_in_head(set_of_dict):
            if len(set_of_dict) == 0:
                raise KeyError("key '{}' is not in this set".format(key))
            else:
                v_in_head = set_of_dict[0].get(key)
                if v_in_head is not None:
                    return v_in_head
                else:
                    get_from_dict_in_head(set_of_dict[1:])
        return get_from_dict_in_head(self.all_shelves)

    def __del__(self):
        """
        On 'destruction', close all references to shelves 
        Returns:

        """
        self.alogger.debug("Closing all open shelves")
        for a_shelf in self.all_shelves:
            a_shelf.close()
        self.alogger.debug("Closing all open shelves => DONE")

class PhonemesFromGraphemes:

    MAX_LENGTH_TO_SPEAK = 10  # if I give more than this, espeak fails to do a good job

    def __init__(self, alogger: logging.Logger):
        self.alogger = alogger

    def set_log_level(self, log_level):
        """
            log_level: one of logging.{WARNING, ...} 

        """
        self.alogger.setLevel(log_level)

    def graphs2phones(self, s):
        """
            Graphemes to Phonemes: 
            Takes a sentence, returns an array of graphemes strings (one per number of words in original sentence)
            Example(s): 
            > graphs2phones('hello world bla and ble')
            > graphs2phones(' wasuuuppp!')
        """
        phs = check_output(["/usr/local/bin/speak", "-q", "-x" ,'-v', 'en-us' ,s]).decode('utf-8')
        return [w for w in phs.strip().split(" ") if w != ' ']

    def take_time(self, code_snippet_as_string):
        """
            Measures the time it takes to execute the code snippet
            provided as string. 
            Returns: the value of the invocation + number of seconds it took. 
            Example(s): 
            > r, secs = take_time("2 + 2")
            > print("result = {}, time = {} secs".format(r, secs))
        """
        start = timer()
        r = eval(code_snippet_as_string)
        end = timer()
        return (r, end - start)

    def graphemes_to_phonemes(self, words_in_sent):
        """
            Takes a list of words and returns a list of tuples
            (grapheme: phoneme)
            Example:
            > graphemes_to_phonemes(["luis", "papa"])
            [('luis', "lj'u:Iz"), ('papa', "pa#p'A:")]
        """
        # First step: generate all sounds of words as if they were "alone" (ie, not in a sentence)
        # We want to avoid a combination of words making only 1 sound
        # For example (depending on accent): "what's up?"
        # So in order to do that we'll introduce a word with a unique sound between the words,
        # generate phonemes and then process them smartly:
        # separator for words in sentence
        separator = {"str": "XXX"}
        separator["sound"] = ''.join(self.graphs2phones(separator["str"]))
        #
        how_many_words = len(words_in_sent)
        num_batches = (how_many_words // self.MAX_LENGTH_TO_SPEAK) + int(how_many_words % self.MAX_LENGTH_TO_SPEAK != 0)
        result_array = [] # {}
        for i in range(num_batches):
            words_in_batch = words_in_sent[i * self.MAX_LENGTH_TO_SPEAK: (i + 1 ) *self.MAX_LENGTH_TO_SPEAK]
            sent_augm = ' '.join \
                ([w1 + ' ' + w2 for w1, w2 in list(zip([separator["str"] ] *len(words_in_batch), words_in_batch))]) + " " + separator["str"]
            phonemes_strs_augm = self.graphs2phones(sent_augm)
            # there we go: all (indexes of) sounds that we are interested in.
            seps_idxs = [i for i ,v in enumerate(phonemes_strs_augm) if v.endswith(separator["sound"]) or v.startswith(separator["sound"]) ]
            how_many_separators = len(seps_idxs)

            all_sounds = list(map(
                lambda t: ' '.join(phonemes_strs_augm[t[0] + 1: t[1]]),
                list(zip(seps_idxs[:-1], seps_idxs[1:]))))
            result_array += list(zip(words_in_batch, all_sounds))
        return result_array


    def dict_graphemes_to_phonemes(self, words_in_sent) -> dict:
        as_phon_graph_list = self.graphemes_to_phonemes(words_in_sent)
        return {ph: graph for (graph, ph) in as_phon_graph_list}


    def graphemes_to_phonemes_to_shelves(self, words_in_sent, shelf_filename):
        """
            Takes a list of words and returns a list of tuples
            (grapheme: phoneme)
            Example:
            > graphemes_to_phonemes(["luis", "papa"])
            [('luis', "lj'u:Iz"), ('papa', "pa#p'A:")]
        """
        # let's do this in batches:
        how_many_words = len(words_in_sent)
        num_batches = (how_many_words // self.MAX_LENGTH_TO_SPEAK) + int(how_many_words % self.MAX_LENGTH_TO_SPEAK != 0)
        result_dict = shelve.open(shelf_filename, flag='c')

        try:
            for i in range(num_batches):
                batch_begin = i * self.MAX_LENGTH_TO_SPEAK
                batch_end = batch_begin + self.MAX_LENGTH_TO_SPEAK
                words_in_batch = words_in_sent[batch_begin: batch_end]
                result_for_batch = self.graphemes_to_phonemes(words_in_batch)
                if i % 1000 == 0:
                    self.alogger.info("batch {} out of {}: words_in_sent[{}:{}] => {}".format(i + 1, num_batches, batch_begin, batch_end, result_for_batch))
                #
                for word, sound in result_for_batch:
                    existing_set = result_dict.get(sound)
                    result_dict[sound] = (set(existing_set) if existing_set is not None else set()).union({ word })
                result_dict.sync()
        finally:
            self.alogger.info("Closing shelf '{}'".format(shelf_filename))
            result_dict.close()



import words_2_vectors
import os

def generate_from_word2vec(mw: words_2_vectors.ModelWrapper, pg: PhonemesFromGraphemes, start: int, n: int, a_dir: str) -> str:
    assert a_dir is not None
    if not os.path.exists(a_dir):
        pg.alogger.info("Directory '{}' does not exist. Creating...".format(a_dir))
        os.makedirs(a_dir)
    shelf_filename = os.path.join(a_dir, "shelf_from{}_for{}.shelf".format(start, n))
    msg = "Generating sounds for words {} to {} of Model; writing in '{}'".format(start, start + n - 1, shelf_filename)
    pg.alogger.info(msg)
    pg.graphemes_to_phonemes_to_shelves(words_in_sent=mw.model.index2word[start:start + n], shelf_filename=shelf_filename)
    pg.alogger.info("DONE => {}".format(msg))

def generate_whole_word2vec_vocab(mw: words_2_vectors.ModelWrapper, pg: PhonemesFromGraphemes):
    words_per_batch = 500000
    how_many_words = len(mw.model.vocab)
    num_batches = (how_many_words // words_per_batch) + int(how_many_words % words_per_batch != 0)
    # directory
    # let's choose one directory where to write data
    dir_name_prefix = "sounds_dir"
    idx = 0
    while os.path.exists(os.path.join(dir_name_prefix, str(idx))):
        idx += 1
    a_dir = os.path.join(dir_name_prefix, str(idx))
    os.makedirs(a_dir)
    #
    pg.alogger.info("Generating sounds for all words in model;results will be saved in directory '{}'".format(a_dir))
    for i in range(num_batches):
        generate_from_word2vec(mw, pg, start=i * words_per_batch, n = words_per_batch, a_dir=a_dir)
    pg.alogger.info("DONE => Generating sounds for all words in model")
    return a_dir

